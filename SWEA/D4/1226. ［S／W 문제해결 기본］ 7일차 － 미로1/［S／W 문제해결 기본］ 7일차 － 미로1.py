"""
1. 큐를 활용하여 미로를 탐색하자
2. 상, 하, 좌, 우 델타 탐색을 하며 갈 수 있는 경로가 있다면 큐에 추가
3. 지나온 길(현재 위치)를 길로 만들며 다시 탐색하지 않도록 하자
4. 도착점을 만나거나 큐가 비어(front, rear 의 교차) 있으면 반복문 종료
"""

for _ in range(1, 11):
    tc = input()
    maze = [list(input()) for _ in range(16)]  # 지나온 길을 벽(1)으로 만들며 지나가기 위해 2차원 리스트로 미로 만들기
    r_q = [(0, 0)] * 16 ** 2                   # 탐색 가능한 경로를 담는 큐 -> 큐의 크기는 미로의 크기만큼 설정
    front = -1                                 # 큐의 공간을 미리 확보하고 인덱스로 제어하기 위해 front, rear 변수 선언
    rear = 0                                   # 시작점을 큐에 넣기 위해 rear 는 0부터 시작
    r_q[rear] = (1, 1)                         # 시작점은 항상 1, 1임
    dx = [0, 0, -1, 1]                         # 델타 탐색을 위한 리스트 -> 상, 하, 좌, 우 순서로 탐색 예정
    dy = [1, -1, 0, 0]
    result = 0                                 # 성공 여부를 표시할 변수 -> 성공 시 1, 실패 시 0

    while True:
        front += 1                             # 현재 위치를 경로 큐의 deque 한 위치로 변경
        y, x = r_q[front]                      # 언패킹 활용하여 현재 x, y 좌표 변수에 저장
        maze[y][x] = 1                         # 현재 위치를 벽(1)으로 만들어 다시 탐색하지 않도록 함

        for i in range(4):                     # 델타 탐색을 위한 반복문
            tx = x + dx[i]                     # 탐색 타겟을 변수에 저장 (현재 위치 + 델타 탐색 위치)
            ty = y + dy[i]
            if maze[ty][tx] == '3':            # 만약 사방 중 도착지점이 있다면
                result += 1                    # 성공 여부를 표시할 변수에 1 추가 후 반복문 종료
                break
            if maze[ty][tx] == '0':            # 만약 사방 중 갈 수 있는 길이 있다면
                rear += 1                      # enqueue 를 위해 rear 1 증가 후 탐색 타겟 큐에 저장
                r_q[rear] = (ty, tx)
        # --- 현재 위치에서 델타 탐색 끝 ---

        if result:                             # 만약 도착지점을 만났다면
            break                              # while 문 까지 종료
        if front >= rear:                      # 만약 더 이상 갈 곳이 없다면 (front 와 rear 가 교차하여 큐가 비었다면)
            break                              # while 문 종료 -> result 는 아직 0

    print(f'#{tc} {result}')                   # 테스트 번호와 함께 성공 여부 출력
